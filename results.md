<table>
    <thead>
        <tr>
            <th>Размер</th>
            <th>Задержка</th>
            <th>Синхронный вариант</th>
            <th>Асинхронный вариант</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=2 align="center">1 Мб</td>
            <td rowspan=1 align="center">Есть</td>
            <td align="center">0:00:11.258298</td>
            <td align="center">0:00:02.089553</td>
        </tr>
        <tr>
            <td align="center">Нет</td>
            <td align="center">0:00:00.024650</td>
            <td align="center">0:00:00.744475</td>
        </tr>
        <tr>
            <td rowspan=2 align="center">100 Мб</td>
            <td rowspan=1 align="center">Есть</td>
            <td align="center">0:18:40.316487</td>
            <td align="center">0:03:32.487568</td>
        </tr>
        <tr>
            <td align="center">Нет</td>
            <td align="center">0:00:01.163621</td>
            <td align="center">0:01:10.984854</td>
        </tr>
    </tbody>
</table>

Разница в результатах объясняется тем, что при приспользовании асинхронности тратится время на создание сложных объектов, чтобы поддержать эту асинхронность, и на управление очередью и потоками. Синхронный вариант этого не требует, поэтому без задержки он работает быстрее. При наличии задержки синхронный вариант останавливается на какое-то время, а в асинхронном варианте пока одна корутина стоит на паузе, работают другие, таким образом во время задержки программа не простаивает, а выполняет все те затратные действия, которые я описал ранее, что в итоге даёт нам выигрыш по времени.
Сначала я думал, что ситуация изменится, если увеличить размер файлов (предположение было в том, что время на создание асинхронных объектов сравнимо со временем чтения файлов и если размер файлов увеличить, то накладные расходы будут занимать лишь малую долю). Однако этого не произошло. Результат аналогичен исследованию с файлами меньшего размера.